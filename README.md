[Compile Time And Runtime](#compile-time-and-runtime)

[Upcasting](#upcasting)

[Accessing Derived class member using Base type pointer - Downcasting](#accessing-derived-class-member-using-base-type-pointer---downcasting)


## Compile Time And Runtime
- **Compile Time**: Occurs during compilation, where source code is translated into machine code.
- **Runtime**: Occurs during program execution, where machine code is executed by the computer.

### Compile Time Errors
**Syntax Errors**:

Syntax errors occur when the code violates the rules of the programming language syntax.

```cpp
int x = 10;
std::cout << "The value of x is: " << x  // Missing semicolon
```

**Type Errors**:

Type errors occur when there is a mismatch between the types of operands in an expression.

```cpp
int x = 10;
std::cout << "The value of x is: " << x << std::endl; // '<<' expects two operands
```

**Undefined Symbols**:

Undefined symbol errors occur when the compiler cannot find a definition for a symbol used in the code.

```cpp

    int main() {
        foo(); // 'foo' is not defined
        return 0;
    }
```

### Runtime Errors:
Runtime errors occur during the execution of the program and are detected by the runtime environment. These errors occur when the program encounters unexpected conditions or behavior that cannot be handled.

**Division by Zero**:
Division by zero occurs when attempting to divide a number by zero, which is undefined.

```cpp

int numerator = 10;
int denominator = 0;
int result = numerator / denominator; // Division by zero
```

**Null Pointer Dereference:**

Null pointer dereference occurs when attempting to access or modify the value pointed to by a null pointer.

```cpp
int* ptr = nullptr;
*ptr = 10; // Null pointer dereference
```

**Out of Bounds Access**:

Out of bounds access occurs when attempting to access elements of an array or container beyond its valid index range.


```cpp
int arr[5] = {1, 2, 3, 4, 5};
int value = arr[10]; // Out of bounds access
```

**Memory Allocation Failures**:

Memory allocation failures occur when the program fails to allocate memory dynamically using operators like new or malloc.

```cpp
int* ptr = new int[1000000000000]; // Memory allocation failure
```

## Upcasting
- It involves treating a derived class object as a base class object.
- This means that you're casting a pointer or reference to a derived class object to a pointer or reference of one of its base classes.

```cpp
Derived derived_obj;
Base* base_ptr = &derived_obj;
```

- An object of the `Derived` class named `derived_obj` is created.
- A pointer `base_ptr` of type `Base*` is assigned the address of `derived_obj`. This is possible because a derived class object can be treated as a base class object due to inheritance.
- Using `base_ptr`, we can only access members that are part of the `Base` class.
- `Derived` class member cannot be accessed through `base_ptr`.

## Accessing Derived class member using Base type pointer - Downcasting
- You can access derived class members in an upcasted pointer or reference by explicitly downcasting it back to the derived class type.
- Downcasting involves casting a pointer or reference of a base class type to a pointer or reference of a derived class type.

```cpp
Derived derived_obj;
Base* base_ptr = &derived_obj;

/* Downcasting */
Derived* derived_ptr = dynamic_cast<Derived*>(base_ptr);
```
## Virtual Function And Upcasting

- If you have a virtual function in the base class and you override it in the derived class, then using upcasting, the overridden function from the derived class will be accessible, not the base class function.
- Otherwise, the base class virtual function will be called.

## Compiler-Generated Constructors in C++

If we don't provide any constructors for a class, the compiler generates several constructors for you. These are commonly referred to as the **"compiler-generated constructors"** or **"default constructors"**. The constructors generated by the compiler include:


- Default Constructor
- Copy Constructor
- Copy Assignment Operator
- Move Constructor
- Move Assignment Operator

## Function Stack Frame

- A function's stack frame:
  - Represents a segment of memory.
  - Allocated on the call stack.
  - Stores information pertaining to the function's invocation and execution.
- Upon function invocation:
  - A new stack frame is created.
  - Positioned atop the call stack.
- Crucial details stored within the stack frame include:
  - Function parameters.
  - Local variables.
  - Return address.
  - Occasionally, supplementary bookkeeping data.

## Constructors in C++

- **Parameter Constructor**: Initializes an object with specified parameters. (Pre C++11)
- **Default Constructor**: Initializes an object without any arguments. (Pre C++11)
- **Copy Constructor**: Creates a new object as a copy of an existing object. (Pre C++11)
- **Conversion Constructor**: Implicitly converts one type to another during object initialization. (Pre C++11)
- **Explicit Constructor**: Prevents implicit conversions and requires explicit use during object initialization. (C++11)
- **Move Constructor**: Transfers resources from a temporary object to another object. (C++11)
- **Forwarding Constructor**: Forwards arguments to another constructor within the same class. (C++11)
- **Initializer List Constructor**: Initializes member variables using initializer lists. (C++11)
- **Constructor Delegation**: Invokes another constructor within the same class to perform initialization. (C++11)

## Default Constructor

If a default constructor is not explicitly provided by the programmer, the compiler does not automatically generate one. However, the compiler generates a default constructor when it's needed.

1. If a class doesn't have any constructors and it's based on another class that does have a default constructor, then the compiler has to make a default constructor for the new class.

2. When a class doesn't have any constructors, but it includes an object from another class that does have a default constructor, the compiler has to make a default constructor for the first class.

3. If a class has virtual functions but no default constructor, the compiler creates one to set up virtual pointer (VPtr).

4. ?? Class with virtual base class ??

## Constructor Call Order
Order of calls in the prologue (before the constructor body begins execution) and epilogue (after the constructor body completes execution) of a default constructor in C++ is typically as follows:

**Prologue**

1. Memory allocation for the object (e.g., stack allocation for local variables or heap allocation using `new` for dynamically allocated objects).

- Is memory allocation done from prologue?

2. Initialization of member variables with initializers.
3. Call to the constructor of the base class (if the class inherits from a base class).

**Epilogue**

1. Call to destructors for initialized member variables (if any) or deallocation of dynamically allocated memory.
2. Call to the destructor of the base class for cleanup.

## Memory Segments
- **Stack**:
  - Used for storing local variables, function parameters, and return addresses.
  - Automatically allocated and deallocated as functions are called and return.
  - Fixed-size memory region that grows and shrinks during program execution.

- **Heap**:
  - Used for dynamic memory allocation.
  - Large pool of memory for allocating memory blocks of varying sizes.
  - Memory management is the programmer's responsibility.
  - Memory allocated on the heap isn't automatically deallocated.

- **Data Segment**:
  - Used for storing initialized global and static variables.
  - Contains variables with fixed sizes and explicit initializers.
  - Allocated before program execution and remains constant in size during runtime.

- **Code Segment**:
  - Used for storing executable code instructions.
  - Mapped into memory when the program is loaded for execution.
  - Remains constant throughout program execution.

## Construction of a Class Object in C++

- **Memory Allocation**:
  - When an object of a class is created, memory is allocated for that object. The size of the memory allocated depends on the size of the class and its members.

- **Constructor Call**:
  - After memory allocation, the constructor of the class is called. The constructor is a special member function of the class responsible for initializing the object's state. It can initialize member variables, allocate resources, and perform any other necessary setup.

- **Initialization**:
  - Inside the constructor, member variables can be initialized either with default values or with values provided by the constructor's parameters.

- **Execution of Constructor Body**:
  - The constructor's body contains any additional initialization logic or code that needs to be executed during object creation. This could include initializing base class subobjects, calling other member functions, or performing any necessary setup.

- **Completion of Object Construction**:
  - Once the constructor has finished execution, the object is considered fully constructed and ready for use.

- **Object Destruction**:
  - When the object goes out of scope or is explicitly deleted using the `delete` operator, the destructor of the class is called. The destructor is responsible for releasing any resources acquired by the object during its lifetime and performing cleanup operations.

## Object Creation vs Constructor 
- **Object Creation**:
  - Refers to the process of instantiating an object of a class.
  - Involves allocating memory for the object and initializing its state.
  - Occurs when you declare a variable of a class type or dynamically allocate memory for an object using operators like `new` (in C++).

- **Constructor**:
  - A special member function of a class that is automatically called when an object of that class is created.
  - Responsible for initializing the newly created object's state.
  - Can initialize member variables, allocate resources, and perform any other necessary setup.
  - Used to ensure that objects are properly initialized before they are used.

In summary:
- Object creation is the process of creating an instance of a class.
- A constructor is a method within a class that is invoked during the object creation process to initialize the object's state.

```cpp
#include<iostream>

using namespace std; /* Bad practice */

#define line(msg) cout<<"----------"#msg"----------\n";

class Animal {
public:
    Animal() {

    }
    void fun() {

    }
};

class Tiger : public Animal {
public:
    Tiger()
    /* Animal::Animal */
    { 

    }
};

int main() {
    Tiger tiger; /* Tiger::Tiger */

    return 0;
}
```
&nbsp;

If the derived class does not have a constructor, the constructor of the base class will only be called from the prologue of the derived class constructor. In such cases, the compiler will generate its own default constructor.
```cpp
class Animal{

    public:
    Animal(){

    }
    void fun(){

    }
};

class Tiger : public Animal{

    public:


};

int main(){

    Tiger tiger; /* Tiger::Tiger */

    return 0;
}
```
```cpp
class Eye{
    public:
    Eye(){

    }
    void fun(){

    }
};

class Lion{

    Eye eyes; 
    public:
    Lion()
    /* Eye :: Eye */
    { 

    }
};

int main(){

    Lion lion; /* Lion :: Lion */
}
```

## Smart Pointer
Smart pointer is a class template that behaves like a pointer but provides automatic memory management, helping to avoid memory leaks and other memory-related errors common in manual memory management.

```cpp
#include<iostream>
using namespace std; /* Bad practice */
#define line(msg) cout<<"----------"#msg"----------\n";

class CA{

    public:
    CA()
    {
        cout << "CA Ctor\n";
    }

    void fun()
    {
        cout << "CA fun\n";
    }

    ~CA()
    {
        cout << "CA D-tor\n";
    }
};

class Smart_ptr
{   
    static void* operator new(size_t) = delete;
    static void* operator new[](size_t) = delete;
    static void operator delete(void*) = delete;
    static void operator delete[](void*) = delete;

    CA* pt;
    public:
    Smart_ptr(CA* pt = NULL) : pt(pt)
    {

    }

    CA* operator->()
    {
        return pt;
    }

    CA& operator*()
    {
        return *pt;
    }

    operator CA*()
    {
        return pt;
    }

    ~Smart_ptr()
    {
        delete pt;
    }

};
int main()
{

    Smart_ptr sm1 = new CA();
    sm1->fun();
    (*sm1).fun();
    return 0;
}
```

### Why Allocating Smart_ptr Objects on the Heap Is Not Recommended:

- Purpose of Smart_ptr: Designed to manage memory of another object, such as a CA object.

- Automated Memory Management: Smart pointers automate memory management, reducing risk of leaks and dangling pointers.

- Manual Management Burden: Allocating Smart_ptr on heap introduces manual memory management for Smart_ptr itself, negating its purpose.

- Potential for Memory Leaks: Manual management of Smart_ptr on heap can lead to memory leaks if not handled properly.

### operator-> and operator*
These two overloaded operators (operator-> and operator*) in the Smart_ptr class provide syntactic sugar to access members of the CA object pointed to by the Smart_ptr. Here's an explanation of each operator along with a dry run:

#### operator->()

- **Description:** This operator allows you to access the members of the CA object as if you were directly accessing them through a pointer to CA.
- **Usage:** When you use the arrow (->) notation with an object of type Smart_ptr, it automatically calls this operator and returns the pointer pt to the CA object.
- **Functionality:** This enables you to access the members of the CA object through the Smart_ptr object directly.
- **Example:** `sm1->fun();`
- **Dry Run:** Assuming sm1 points to a valid CA object, operator->() returns pt, which is a pointer to the CA object. Then, fun() is called on the CA object using the returned pointer.

#### operator*()

- **Description:** This operator allows you to dereference the Smart_ptr object as if it were a pointer to CA.
- **Usage:** When you use the asterisk (*) notation with an object of type Smart_ptr, it automatically calls this operator and returns a reference to the CA object itself.
- **Functionality:** This enables you to access the CA object itself through the Smart_ptr object directly.
- **Example:** `(*sm1).fun();`
- **Dry Run:** Assuming sm1 points to a valid CA object, operator*() returns a reference to the CA object. Then, fun() is called on the referenced CA object.

#### operator CA*()
Defines a type conversion operator in the Smart_ptr class. Specifically, it is a conversion operator to convert the Smart_ptr object to a raw pointer to CA 

(* sm1).fun(); is resolved by both the operator*() and operator CA*().

- CA& operator*(): This overloaded operator dereferences the Smart_ptr object, returning a reference to the CA object itself. Therefore, (*sm1) results in obtaining a reference to the CA object.

- operator CA*(): This conversion operator allows the Smart_ptr object to be implicitly converted to a raw pointer to CA. Therefore, (* sm1) can also be implicitly converted to a CA*.

Given that both operator*() and operator CA*() can be applied to (* sm1), the expression (* sm1).fun(); can be resolved using either of them. However, the compiler prefers the more specific option, which is operator*(), as it directly returns a reference to the CA object.

```cpp
CA& operator*()
{
    return *pt;
}

operator CA*()
{
    return pt;
}
```
#### Copy Constructor With Ownership Transfer
```cpp
Smart_ptr(const Smart_ptr& object) : pt(object.pt)
{
    Smart_ptr& refSP = const_cast<Smart_ptr&>(object);
    refSP.pt = NULL;

}
```
#### Assignment Operator With Swap & Copy
```cpp
void Swap(Smart_ptr& object)
{
    std::swap(this->pt,object.pt);
}

Smart_ptr& operator=(const Smart_ptr& object)
{   
    if(this == &object) return *this;

    Smart_ptr temp(object);
    Swap(temp); 
    /* temp.swap(*this)*/
    return *this;

}
```

This syntax invokes a member function named Swap on the current object (*this), passing temp as an argument.
```cpp
Swap(temp);
```
This syntax calls a member function named swap on the temp object, passing *this (the current object) as an argument.
```cpp
temp.swap(*this)
```
## Lvalue And Rvalue
- Lvalue:
  - An lvalue (locator value) refers to an object that occupies some identifiable location in memory (i.e., it has an address).
  - Lvalues often correspond to named variables or objects that persist beyond a single expression.
  - You can take the address of an lvalue using the address-of operator (&).
  - Examples of lvalues include variables, references, and dereferenced pointers.

- Rvalue:
  - An rvalue (right value) refers to an object that does not necessarily have an identifiable memory location.
  - Rvalues are typically temporary and short-lived, often used as temporary values during expressions or as the result of expressions.
  - You cannot take the address of an rvalue.
  - Examples of rvalues include literal constants, temporary objects created during expression evaluation, and the result of certain functions (like overloaded operators).

## Move Constructor

- Rvalue References:
  - Rvalue references, denoted by `&&`,type of reference that can bind to temporary objects and non-const rvalues.
  - They are used to distinguish between lvalues and rvalues, allowing functions and constructors to behave differently based on whether they are passed an lvalue or an rvalue.

- Move Semantics:
  - Move semantics work by enabling the efficient transfer of resources (such as memory allocations) from one object to another, rather than making expensive copies.

- Move Constructors:
  - Move constructors are special member functions that take an rvalue reference as a parameter.
  - They are used to implement move semantics, allowing objects to efficiently transfer resources from temporary objects or objects about to be destroyed.
  - Move constructors are invoked automatically when an object is constructed from an rvalue or when an object is passed to a function by value.
  - Avoids Deep Copy

```cpp
CA(CA&& par) noexcept : a(par.a) 
{
  par.a = NULL;
  cout << "Move Constructor [" << this << "] a = [ " << a << " ]\n";
}
```
```cpp
#include<iostream>
using namespace std; /* Bad practice */
#define line(msg) cout<<"----------"#msg"----------\n";

class CA
{
    int* a;

    public:
    CA() : a(new int(1000))
    {
        cout << "Constructor [" << this << "] \n";
    }

    CA(const CA& o) : a(new int(*o.a))
    {
        cout << "Deep Copy [" << this << "] a = [ "<< a << " ]\n";
    }

    CA(CA&& par) noexcept : a(par.a) 
    {

        par.a = NULL;
        cout << "Move Constructor [" << this << "] a = [ " << a << " ]\n";
    }

    ~CA() noexcept
    {   
        cout << "Destructor [" << this << "] \n";
        delete a;
    }
};

/*
-fno-elide-constructor
*/
CA Factory()
{
    line(In factory fun);
    CA temp;
    cout << "Do Business\n";

    line();
    return temp;
}

void fun(CA obj)
{
    cout << "Start Business\n";
}
int main()
{   
    
  CA obj = Factory();
  line(main);

  return 0;
}
```
```plaintext
----------In factory fun----------
Constructor [0x7fffaf4b2700] 
Do Business
--------------------
Move Constructor [0x7fffaf4b2740] a = [ 0x562f842fc2c0 ]
Destructor [0x7fffaf4b2700] 
Move Constructor [0x7fffaf4b2738] a = [ 0x562f842fc2c0 ]
Destructor [0x7fffaf4b2740] 
----------main----------
Destructor [0x7fffaf4b2738] 
```

## noexcept
- `noexcept` is a specifier used to declare that a function will not throw any exceptions.
- It is used to provide information to the compiler and to help with code optimization, as well as to convey the exception safety guarantees of functions.

```cpp
void myFunction() noexcept {
  
}
```
## std::move()
- `std::move()` is a utility function provided by the C++ Standard Library that facilitates the use of move semantics. 
- It is used to convert an lvalue into an rvalue reference, enabling the efficient transfer of resources (such as dynamically allocated memory) from one object to another.
- It allows you to explicitly indicate that you are willing to "move" the resources from one object to another, rather than making a copy.
- `std::move()` is commonly used in conjunction with move constructors, move assignment operators, and functions that accept rvalue references as parameters.

### How it Works:

- When you pass an object to `std::move()`, it casts the object to an rvalue reference, effectively indicating that you are willing to transfer ownership of its resources.
- This allows move constructors or move assignment operators to be invoked, rather than copy constructors or copy assignment operators, when passing the object to functions or assigning it to other objects.
- It does not move any resources itself; it simply enables move operations by casting the object to an rvalue reference.

### Usage:

- `std::move()` is commonly used in scenarios where you have a temporary object or an object that you no longer need and want to transfer its resources to another object efficiently.
- It is often used when passing objects to functions that expect rvalue references, such as move constructors or move assignment operators.
- `std::move()` should be used with caution to avoid dangling references or undefined behavior, as it does not perform any safety checks.

```cpp
MyClass(MyClass&& other) noexcept {
    // Move resources from 'other' to 'this'
}

int main() {
MyClass obj1;
MyClass obj2 = std::move(obj1); // Move 'obj1' resources to 'obj2'
return 0;
}
```

```cpp
#include<iostream>
using namespace std; /* Bad practice */
#define line(msg) cout<<"----------"#msg"----------\n";

class CA
{
    int* a;

    public:
    CA() : a(new int(1000))
    {
        cout << "Constructor [" << this << "] \n";
    }

    CA(const CA& o) : a(new int(*o.a))
    {
        cout << "Deep Copy [" << this << "] a = [ "<< a << " ]\n";
    }

    
    CA(CA&& par) noexcept : a(par.a) 

    {

        par.a = NULL;
        cout << "Move Constructor [" << this << "] a = [ " << a << " ]\n";
    }

    ~CA() noexcept
    {   
        cout << "Destructor [" << this << "] \n";
        delete a;
    }
};

void f1(CA obj)
{
    cout << "Apple\n";
}

void f2(CA& obj)
{
    cout << "Apple\n";
}

void f3(CA&& obj)
{
    cout << "Apple\n";
}

int main()
{   

    CA obj;
    line();
    //f1(obj);
    line();

    f1(std::move(obj)); 
    /*
    move - priotizes the move constructor over copy constructor if mover constructor exist.

    */

    // f2(std::move(obj));
    /*error -  Sending lvaue in rvalue*/

    f3(std::move(obj)); /* rvalue reference is passed */
    return 0;
}
```

- std::move(): prioritizes the move constructor over the copy constructor if the move constructor exists.

## std::forward<>()
- `std::forward()` is used to forward arguments passed to a function to another function, typically within a template context.
- It allows you to preserve the value category (lvalue or rvalue) of the forwarded arguments, enabling efficient forwarding of both lvalues and rvalues.

### Perfect Forwarding:
- Perfect forwarding refers to forwarding function arguments in a way that preserves their original value category (lvalue or rvalue).
- It allows you to forward arguments to other functions or constructors without unnecessary copying or moving, optimizing performance.

```cpp
#include <iostream>

void anotherFunction(int&& value) {
    std::cout << "Received rvalue: " << value << std::endl;
}

void anotherFunction(int& value) {
    std::cout << "Received lvalue: " << value << std::endl;
}

template<typename T>
void process(T&& arg) {
    anotherFunction(std::forward<T>(arg));
}

int main() {
    int x = 42;
    process(x); /* lvalue */
    process(std::move(x)); /* rvalue */
    return 0;
}
```

## Universal Reference And RValue Reference

- **Universal Reference**:
  - Universal references are declared using the syntax `T&&`, where `T` is a template parameter.
  - They are typically used in function templates to accept any type of argument, preserving its original value category (lvalue or rvalue).
  - Universal references are used in perfect forwarding scenarios, where you want to forward arguments to other functions while preserving their original value category.
```cpp
void process(T&& arg)
```

- **Rvalue Reference**:
  - Rvalue references are declared using the syntax `T&&`, where `T` is a **type (not a template parameter)**.
  - They are used to bind to temporary objects or expressions that can be safely moved from.
  - Rvalue references are commonly used in move semantics, allowing efficient transfer of resources from one object to another.
  - They bind only to rvalues; they cannot bind to lvalues. This restriction ensures that they are used primarily for temporary objects.
```cpp
void process(int&& arg)
```

## Pack
- A parameter pack allows functions and templates to accept a variable number of arguments of arbitrary types. 
- Parameter packs are particularly useful when working with variadic templates, which are templates that can accept an arbitrary number of template arguments.

```cpp
template<typename T,typename... pack>
void printMe(T t,pack... p) /* Pack Received */
{
    cout << t << '\t';
    printMe(p...); /* UnPacking */
}
```

```cpp
printMe(1, "hello", 3.14, 'A');
```
### Functional Specialization

## Delete And Default

- **delete**:
  - The `delete` keyword is used to explicitly prevent the compiler from generating a particular member function.
  - Explicitly requesting the compiler to generate default member 
  - Preventing implicit generation of certain member functions: By explicitly marking a member function as delete, you prevent the compiler from generating the default implementation of that function.
```cpp
class MyClass {
public:
    MyClass() = delete;
    MyClass(const MyClass&) = delete; 
    MyClass& operator=(const MyClass&) = delete; 
};
```

- **default**:
  - The `default` keyword is used to explicitly request the compiler to generate the default implementation of a member function.
  - This is useful when you want to retain the default behavior provided by the compiler, but you have explicitly defined other member functions.
```cpp
class MyClass {
public:
    MyClass() = default; 
    MyClass(const MyClass&) = default; 
    MyClass& operator=(const MyClass&) = default; 
};
```
## Operator Overload
### Overloading new operator
```cpp
static void* operator new(size_t size)
{   
    cout << "Operator new\n";
    return malloc(size);
}
```

### Overloading new[] operator
```cpp
static void* operator new[](size_t size)
{   
    cout << "Operator new[]\n";
    return malloc(size);
}
```
### Overloading delete operator
```cpp
static void operator delete(void* ptr)
{   
    cout << "Operator Delete\n";
    free(ptr);
}
```

### Overloading delete[] operator
```cpp
static void operator delete[](void* ptr)
{   
    cout << "Operator Delete\n";
    free(ptr);
}
```

## Templates
- Function templates allow you to define a single function that can work with different data types.

**Function Template**
```cpp
template<typename T>
T add(T a, T b) {
    return a + b;
}
```

**Class Template**
```cpp
template<typename T>
class Array {
private:
    T* data;
    size_t size;
public:
};
```

### Trailing return type deduction
- The "trailing return type" syntax allows to specify the return type of a function template after the function parameters, using the `auto` keyword or `decltype`.
- This syntax is particularly useful when the return type depends on the function parameters or involves complex type expressions.

```cpp
template<typename T1,typename T2>
auto MulFun(T1 x,T2 y) -> double    /* return will be double */
```

`decltype(x * y)` is used as the trailing return type, which deduces the return type of the function based on the type of the expression x * y.
```cpp
template<typename T1,typename T2>
auto MulFun(T1 x,T2 y) -> decltype(x*y)  (evaluates the outcome and keeps the return type )
```

Trailing return type deduction can also be used with `auto` for deducing the return type of a function from its implementation:
```cpp
template<typename T1,typename T2>
auto MulFun(T1 x,T2 y) auto
{
  /* code */
}
```

In C++14, the auto return type deduction feature eliminates the necessity for trailing return type specification.
```cpp
template<typename T1,typename T2>
auto MulFun(T1 x,T2 y)
{
  /* code */
}
```

We encounter two return types: 2.14 (double) and 2 (int). Auto deduction is not capable of discerning between these types, hence we are obliged to utilize trailing deduction, as illustrated below:
```cpp
template<typename T1,typename T2>
auto MulFun14_1(T1 x,T2 y) -> double
{
    int par = 1;
    cout << "MulFun14_1 for T1 = [" << typeid(T1).name() << "] \t T2 = [" << typeid(T2).name()<< "]\n";

    if( 10 == par)
    {
        return 2.14;
    }
    return 2;
} 
```
## Call Back And Function Pointer
**Function Pointer**

- A function pointer is a variable that stores the address of a function.
- It allows you to call a function indirectly through the pointer.

```cpp
returnType (*pointerName)(parameterTypes);
```

**Callback**
- A callback is a function that is passed as an argument to another function.
- The receiving function can then call the callback function at a specific time or in response to an event.

```cpp
/* Function that takes a callback as an argument */
void performOperation(int (*callback)(int, int)) {

    /* Call the callback function */
    int result = callback(3, 5);
    std::cout << "Result: " << result << std::endl;
}

/* Callback function */
int add(int a, int b) {
    return a + b;
}

/* Passing the callback function to performOperation */
performOperation(add); 
```

### using and typedef
**typedef** and **using** are both utilized in C++ for creating aliases.

In C++11 and later versions, the **using** keyword is preferred over **typedef** for defining aliases, including function pointers.

To define a function pointer type that matches the signature of a callback function, you can use the **using** or **typedef** keyword as follows: 

```cpp
typedef int (*Callback)(int, int);

void performOperation(Callback callback) {
    int result = callback(3, 5);
    std::cout << "Result: " << result << std::endl;
}
```

```cpp
using FPTR = void (*)();

void VendorFun1(FPTR fp)
{

    std::cout << "Vendor job started\n";
    (*fp)(); /* Call back */
    std::cout << "Vendor job completed\n";
}
```

This function pointer is of type FPTR, which is defined as a pointer to a function returning void and taking no arguments.

**NOTE:** In C++, when you pass a function name as an argument to a function, the function name automatically decays into a pointer to the function. This happens because functions are not passed by value; instead, they are passed by their address or pointer.

```cpp
VendorFun(Fun1);
VendorFun(&Fun1);
```
Both lines are functionally equivalent. In the first line, Fun1 is the name of a function, but it is automatically converted into a function pointer when passed as an argument to VendorFun. In the second line, &Fun1 explicitly takes the address of the function Fun1, resulting in a function pointer.

There is a function named VendorFun() which takes a function pointer fp as its parameter.
```cpp
void VendorFun(FPTR fp)
{
    cout << "vendor job started\n";
    (*fp)();
    fp();
    cout << "vendor job completed\n";
    line();
}
```
There is a function named VendorFun() which takes a function pointer fp as its parameter.
(*fp)();: This syntax dereferences the function pointer fp and calls the function it points to. It is the traditional way to call a function using a function pointer.

fp();: This syntax directly calls the function pointer fp as if it were a regular function. In C++, a function pointer can be called without explicitly dereferencing it. This shorthand notation was introduced to simplify the syntax when working with function pointers.

###  Curiously Recurring Template Pattern : CRTP

- The Curiously Recurring Template Pattern (CRTP) is a design pattern in C++.
- It involves a class template inheriting from a class template specialization of itself.
- The CRTP is utilized to achieve compile-time polymorphism.
- It enables **static polymorphism**, allowing the derived class to access members and methods of the base class.


```cpp
#include <iostream>


/* C R T P : Curiously Recurring Template Pattern */
template<typename Derived>
class Base
{

    public:
    void VendorFunction()
    {

        std::cout << "Vendor Function\n";

        static_cast<Derived*>(this) -> class_derived_function();

        std::cout << "Vendor Function End\n";
    }
    private:
    int x{0};
};

class Derived : public Base<Derived>
{

    public:
    void class_derived_function()
    {
        std::cout << "Class Derived Fuction Start\n";
    }
    private:
    int y{0};
};

class Derived2 : public Base<Derived2>
{

    public:
    void class_derived_function()
    {
        std::cout << "Class Derived 2 Fuction Start\n";
    }
    private:
    int y{0};
};
int main()
{

    Derived d;
    Derived2 d2;

    d.VendorFunction();
    d2.VendorFunction();

    return 0;
}
```

Let's break down the statement **a class template inherits from a class template specialization of itself**:

**Class Template:** A class template is a blueprint for creating classes. It's like a generic class that can be parameterized by one or more types or values. For example:


```cpp
template <typename T>
class Base {
    
};
```

**Class Template Specialization:** A class template specialization is a specific instance of a class template where the template parameters are replaced with specific types or values. For example:

```cpp
class Base<int> {
    
};
```

**Inherits from Itself:** In the context of the Curiously Recurring Template Pattern (CRTP), a class template inherits from a specialization of itself. This means that the class template is used as a base class for its own specialization. For example:

```cpp
template <typename Derived>
class Base {
    
};

class Derived : public Base<Derived> {
    
};
```

### CallBack Member Function

```cpp
using FPTR = void(CVendor::*)();

void VendorFun(CVendor& cv, FPTR fp)
{
    cout << "vendor job started\n";

    (cv.*fp)(); //member function callback

    cout << "vendor job completed\n";

}

int main()
{
    CVendor cv1(111, 222);
    CVendor cv2(100, 200);

    FPTR fp1 = &CVendor::f1;
    FPTR fp2 = &CVendor::f2;

    VendorFun(cv1, fp1);
    VendorFun(cv1, fp2);
    VendorFun(cv2, fp1);
    VendorFun(cv2, fp2);

    return 0;
}
```

- (cv.*fp)() dereferences the member function pointer fp with respect to the instance cv, effectively calling the member function on cv.
() at the end is the function call operator, indicating the invocation of the member function.

- **CVendor::** This part specifies the class scope to which the member function pointer belongs. In this case, it refers to the CVendor class.

- *: This asterisk denotes that we are declaring a pointer type.

### Call Back Template 

- Call Back of function using template.
- Call back of functor OR Function Object.
```cpp
template<typename T>
void VendorFun(T obj)
{
    cout << "vendor job started T [ " << typeid(T).name() << " ]\n";;
    obj(); //callback
    cout << "vendor job completed\n";
    line();
}


using FPTR = void(*)();

void ClientFun()
{
    cout << "Hi I am from client\n";
}

void Fun()
{
    cout << "Haaaaaaaaaaaaaaa\n";
}

class CA 
/* Functor OR Function Object */
{
    int a{ 0 };
    int b{ 0 };
public:
    CA(int a, int b) :a(a), b(b)
    {
    }
    void operator()()
    {
        cout << "CA Client Code a : " << a << " b=" << b << '\n';
    }
};

int main()
{
    FPTR fp1 = ClientFun;
    FPTR fp2 = Fun;

    /* Passing Function Pointer */
    VendorFun(fp1);
    VendorFun(fp2);

    /* Passing Functor */
    CA obj(102, 103);
    VendorFun(obj);


    return 0;
}
```

### Call Back Functor

```cpp
template<typename T>
void VendorFun(T obj)
{
    cout << "vendor job started T [ " << typeid(T).name() << " ]\n";

    /* Callback */
    obj();

    cout << "vendor job completed\n";
    line();
}

void ClientFun(int p1, int p2)
{
    cout << "ClientFun called p1 : " << p1 << " p2 : " << p2 << '\n';
}

class Shubam
{

public:
    using FPTR = void(*)(int, int);
    Shubam(int i, int j, FPTR fp) :i(i), j(j), fp(fp)
    {
    }
    void operator()() const
    /* Inspector */
    {
        fp(i, j);
    }
private:
    int i;
    int j;
    FPTR fp;
};
int main()
{
    int i = 100;
    int j = 200;
    Shubam::FPTR fp = &ClientFun;

    Shubam shubam(i, j, fp);

    VendorFun(shubam);
    return 0;
}
```

### Callback Lambda

```cpp
template<typename T>
void VendorFun(T obj)
{
    cout << "vendor job started T [ " << typeid(T).name() << " ]\n";
    obj();//callback
    cout << "vendor job completed\n";
    line();
}

int main()
{
    int i = 100;
    int j = 200;

    auto f1 = [=, &i]() { 
        i += 100;  
        cout << "I am from lambda i : " << i << ",j : " << j << '\n'; 
    };
		
    VendorFun(f1);
    return 0;
}
```

## Lambda
- A lambda function is a function object capable of capturing variables in its enclosing scope.
- It provides a concise way to define small, inline functions.
- Lambda functions are often used as callbacks or for short operations.

```cpp
[capture list] (parameter list) mutable(optional) noexcept(optional) -> return_type(optional) {
    /* Function Body */
}
```

- **Capture list:** Specifies which variables from the enclosing scope should be captured by value or by reference. It is optional.
- **Parameter list:** Specifies the parameters of the lambda function. It can be empty if the lambda takes no parameters.
- **Mutable specifier (optional):** Indicates that the lambda function can modify variables captured by value. It is optional.
- **Noexcept specifier (optional):** Specifies whether the lambda function can throw exceptions. It is optional.
- **Return type (optional):** Specifies the return type of the lambda function. It is optional and can be omitted if the compiler can deduce the return type.

### Capturing

#### Capturing By Value & using mutable

```cpp
/*
[capture](parms){body}

capture - capture information outside the function
*/

int main()
{
    std::vector<int> v{1,2,3,4,5};

    int lastResult{-1};

    std::for_each(begin(v),end(v),[lastResult](int n) mutable
    {   
        lastResult = n+1;
      
        std::cout << n << ",";
        std::cout << lastResult << std::endl;
        
    });

    std::cout << std::endl;
    
    std::cout << lastResult << std::endl;

    return 0;
}
```
- Here  is captured as a copy and can be change using mutable inside the lambda body.
- Without mutable we cant change it. It will be read only. 
- If we use[=] variable will become copy and read only.But for static or globat it wont work.

```cpp

static int s_variable = 5;
int global = 10;
int main()
{
    std::vector<int> v{1,2,3,4,5};

    std::for_each(begin(v),end(v),[=]  (int n) 
    {   
        s_variable = 100;
        global = 200;
    });
    
    std::cout << s_variable << std::endl;
    std::cout << global << std::endl;

    return 0;
}
```

#### Capturing by reference

- Capture i,j by reference using &

```cpp
auto f1 = [&i, &j]()  { 
    i += 100; 
    j += 200; 
    cout << "I am from lambda i : " << i << ",j : " << j << '\n'; 
};
```

#### Capturing using this

- this: captures by reference 
- *this: captures by copy. To make changes use mutable

```cpp
struct my
{   

    void fun()
    {  

        auto lptr = [this]() 
        {

            this->counter++;
            std::cout << "Counter inside lambda: " << counter << std::endl;
            
        };

        lptr();


        std::cout << "Counter: " << counter << std::endl;
        
    }

    int counter{0};
};

int main()
{

    my object;

    object.fun();
    object.fun();
    object.fun();
    object.fun();

    return 0;
}
```

```cpp

/* Inspector () operator */
auto f1 = []() {
    cout << "I am from lambda\n"; 
};

/* Mutator () operator */
auto f1 = []() mutable {
    cout << "I am from lambda\n"; 
};

/* Inspector () operator */
auto f1 = [i]() { 
    /*i += 100;*/ 
    /* i passes by value can cannot be updated without using mutable*/
    cout << "I am from lambda\n"; 
};

/* Capture i by value inspector () operator */
auto f1 = [i]() {  
    cout << "I am from lambda i : " << i << '\n';
};

/* Capture i,j by value mutator () operator */
auto f1 = [i, j]() mutable { 
    i += 100; 
    j += 200; 
    cout << "I am from lambda i : " << i << ",j : " << j << '\n'; 
};

/* Capture all by value mutator () operator */
auto f1 = [=]() mutable { 
    i += 100; 
    j += 200; cout << "I am from lambda i : " << i << ",j : " << j << '\n'; 
};

/* Capture all by value inspector () operator */
auto f1 = [=]()  {  
    cout << "I am from lambda i : " << i << ",j : " << j << '\n'; 
};

/* Capture i,j by reference inspector () operator */
auto f1 = [&i, &j]()  { 
    i += 100; 
    j += 200; 
    cout << "I am from lambda i : " << i << ",j : " << j << '\n'; 
};

/* Capture all by reference inspector () operator */
auto f1 = [&]()  { 
    i += 100; 
    j += 200; 
    cout << "I am from lambda i : " << i << ",j : " << j << '\n'; 
};

/* Capture everything by reference except j */
auto f1 = [&,j]()  { 
    i += 100;  
    cout << "I am from lambda i : " << i << ",j : " << j << '\n'; 
};

/* Capture everything by value except i */
auto f1 = [=, &i]() { 
    i += 100;  
    cout << "I am from lambda i : " << i << ",j : " << j << '\n'; 
};	
```

- Members are captured by reference
```cpp
class CA
{
    int x{ 10 };
    int y{ 20 };
public:
    void fun1()
    {
        int a = 111;
        int b = 222;
        /* Members captured by reference and locals captured by value */
        auto fnc = [=]() {
            x += 10;
            //a += 10;//error
            cout << "x=" << x << '\n';
            cout << "y=" << y << '\n';
            cout << "a=" << a << '\n';
            cout << "b=" << b << '\n';
        };
        VendorFun(fnc);
    }

    void fun2()
    {
        int a = 111;
        int b = 222;
        /* Members and locals captured by reference */
        auto fnc = [&]() {
            x += 10;
            a += 10;
            cout << "x=" << x << '\n';
            cout << "y=" << y << '\n';
            cout << "a=" << a << '\n';
            cout << "b=" << b << '\n';
        };
        VendorFun(fnc);
    }
};
```

### Capturing members by value and reference using this

```cpp
class CA
	{
		int x{ 10 };
		int y{ 20 };
	public:
    void fun3()
		{
			int a = 111;
			int b = 222;
			/* Members captured  by reference */
			auto fnc = [this]() {
				x += 10;
				y += 20;
				cout << "x=" << x << '\n';
				cout << "y=" << y << '\n';

			};
			VendorFun(fnc);
		}


		void fun4()
		{
			int a = 111;
			int b = 222;
			/* Members captured  by value */
			auto fnc = [lcl = *this]() {
				//lcl.x += 10;
				//lcl.y += 20;
				cout << "x=" << lcl.x << '\n';
				cout << "y=" << lcl.y << '\n';

			};
			VendorFun(fnc);
		}

		void fun()
		{
			int a = 111;
			int b = 222;

			/* Members captured  by value */

			auto fnc = [*this]() {//c++17 onwards
				//x += 10;
				//y += 20;
				cout << "x=" << x << '\n';
				cout << "y=" << y << '\n';

			};
			VendorFun(fnc);
		}
	};
```

## Virtual Functions
- **vptr:** This is a pointer to the virtual function table (vtable) of the class to which object points.

#### Accessing VTable

```cpp
using FPTR = void(*)();

CC obj2;

//((void(*)())* (long*)*(long*)&obj2)();

/* step 1 reach the vptr */
long* vptr = (long*)&obj2;

/*step 2 reach the vtable */
long* vtable = (long*)*vptr;

/* step 3 reach the function */
FPTR fp=(FPTR)vtable[0];

/* void(*fp)() = (void(*)())vtable[0]; c syntax */


/* step 4 callback */
fp();

/* (*fp)();//c-syntax */

```

```cpp
CA obj;
CA* objPtr = &obj;
CA& objRef = obj;

objPtr->f2(); /* objPtr->vptr->vtable[0](); */

objRef.f2(); /* objRef.vptr->vtable[0](); */
```

#### Working

```cpp
class CA
{
public:
    CA()
    /* setvptr(CA::Vftable) */
    {
    }
    void DoJob()
    {
        /* this->Apple(); //this->vptr->vtable[0](); */
        Apple();
    }
    virtual void Apple()
    {
        cout << "CA::Apple Ooty\n";
    }
    ~CA()
    /* setvptr(CA::Vftable) */
    {
    }
};
class CB :public CA
{
public:
    CB()
    /* CA::CA() , setvptr(CB::Vftable) */
    {
    }
    void Apple() override { cout << "CB::Apple Shimla\n"; }
    ~CB()
    /* setvptr(CB::Vftable) */
    {
    }/* CA::~CA() */
};
```

- The `vptr` (virtual function pointer) is not reset during object destruction. Instead, it remains unchanged from its initialization during object construction.
- During object destruction, the compiler-generated or user-defined destructor is invoked. If the class has a virtual destructor (i.e., declared as `virtual ~ClassName()`), the compiler ensures that the proper destructor(s) for all base classes are called in the correct order.
- This is achieved through the vtable (virtual function table). The vtable contains entries for all the virtual functions of the class, including the destructor(s). When an object is destroyed, the compiler uses the `vptr` to navigate to the appropriate entry in the vtable and invokes the destructor(s) for all the base classes, following the inheritance hierarchy.
- So, it's not about resetting the `vptr` during destruction but rather using it to ensure that the correct destructors are called for all base classes through the vtable mechanism.

### Virtual Destructor

```cpp
#include<iostream>
using namespace std;
#define line(msg) cout<<"________________"#msg"______________________\n"

class CA
{
public:
	static void* operator new(size_t size)
	{
		cout << "CA::operator new\n";
		return malloc(size);
	}
	static void operator delete(void *pv)
	{
		cout << "CA::operator delete\n";
		free(pv);
	}
	CA()
	{
		cout << "CA Ctor\n";
	}
	virtual ~CA()
	{
		cout << "CA D-tor\n";
	}
};

class CB:public CA
{
public:
	CB()
	{
		cout << "CB Ctor\n";
	}
	static void* operator new(size_t size)
	{
		cout << "CB::operator new\n";
		return malloc(size);
	}
	static void operator delete(void* pv)
	{
		cout << "CB::operator delete\n";
		free(pv);
	}
	~CB()
	{
		cout << "CB D-tor\n";
	}
};
	
int main()
{
	CA* pt = new CB();
	line();
	delete pt;

	return 0;
}
```
1. If the destructor in the base class is not virtual:
   - When you delete the object through the base class pointer, only the destructor of the base class is called.
   - This is because the compiler treats the pointer as pointing to an object of the base class type, so it only knows about the base class destructor.
   - This can lead to memory leaks if the derived class has dynamically allocated resources that need to be cleaned up.

2. If the destructor in the base class is virtual:
   - When you delete the object through the base class pointer, the virtual destructor mechanism ensures that the destructor of the most derived class is called.
   - This is achieved by using the virtual function table (vtable) mechanism.
   - Each class with virtual functions has a vtable, which contains pointers to the virtual functions of that class.
   - The vtable of the most derived class contains pointers to all virtual functions, including the destructor.
   - When you delete an object through a base class pointer, the compiler uses the vtable to determine the correct destructor to call, ensuring that the destructors of all classes in the inheritance hierarchy are called in the correct order.
   - This ensures proper cleanup of resources allocated by the derived classes.

#### Why virtual
Using the virtual keyword for a function in a base class is essential when you want to achieve runtime polymorphism and enable dynamic dispatch of function calls to the appropriate derived class implementations. Here's why you should use virtual:

   - **Dynamic Binding:** When a function is declared as virtual in the base class, it allows derived classes to provide their own implementations of that function. During runtime, the appropriate derived class implementation is chosen based on the actual object type, enabling dynamic binding or late binding.

   - **Polymorphism:** Without the virtual keyword, function calls are resolved at compile-time based on the static type of the pointer or reference. This means that if you call a function through a base class pointer or reference, the base class version of the function will always be called, even if the object being referred to is of a derived class. This behavior is called static binding or early binding and does not support polymorphic behavior.

   - **Overriding:** When a function is declared virtual in the base class and overridden in a derived class, it allows the derived class to provide specialized behavior while maintaining a common interface. This is crucial for implementing the Liskov Substitution Principle (LSP) and ensuring that derived classes can be used interchangeably with base class objects without affecting correctness.

   - **Runtime Polymorphism:** Virtual functions enable runtime polymorphism, where the appropriate function implementation is determined at runtime based on the actual type of the object. This is essential for implementing object-oriented design principles like inheritance, encapsulation, and abstraction.

```cpp
#include <iostream>

class base
{
    public:
    void fn()
    {

        std::cout << "Base::Function" << std::endl;
    }
};

class derived : public base
{

    public:
    void fn()
    {
        std::cout << "Derived::Function" << std::endl;
    }
};


int main()
{   

    derived d;

    base* b = &d;

    b->fn();

    return 0;
} 
```
**OUTPUT**
```cpp
Base::Function
```

With Virtual keyword
```cpp
#include <iostream>

class base
{
    public:
    virtual void fn()
    {

        std::cout << "Base::Function" << std::endl;
    }
};

class derived : public base
{

    public:
    void fn()
    {
        std::cout << "Derived::Function" << std::endl;
    }
};


int main()
{   

    derived d;

    base* b = &d;

    b->fn();

    return 0;
} 
```
**OUTPUT**
```cpp
Derived::Function
```


## Principle and Design pattern

1. yagni -> you arn't gonna need it
2. High cohession
3. SRP -> Single Responsibility Priniciple
4. Kiss -> keep it simple and stupid
5. Dry/Die/Wet/Oaoo -> dont repeat yourself/duplication is evil/We Enjoy typing/Once and only once
6. LSP -> Liskov's Substitution Principle

### SRP (Single Responsibility Principle)
The idea is to keep classes focused and cohesive by separating different concerns or responsibilities into separate classes.


```cpp
/* Rejected class ( Violates SRP ) */
class Account
{
public:
    void DoDebitSavings(int Accid, int amount)
    {
        cout << "Debit Savings\n";
    }
    void DoDebitCurrent(int Accid, int amount)
    {
        cout << "Debit Current\n";
    }
};

/* Approved Class */
class SavingsAccount
{
public:
    void DoDebitSavings(int Accid, int amount)
    {
        cout << "Debit Savings\n";
    }
};

class CurrentAccount
{
public:
    void DoDebitCurrent(int Accid, int amount)
    {
        cout << "Debit Current\n";
    }
};
```

### Dry/Die/Wet/Oaoo -> dont repeat yourself/duplication is evil/We Enjoy typing/Once and only once

```cpp
//Rejected class(violates Dry) 
class SavingsAccount
{
public:
    void DoDebitSavings(int Accid, int amount)
    {
        cout << "Open DB\n";
        cout << "Debit Savings\n";
        cout << "Close DB\n";
    }
};

class CurrentAccount
{
public:
    void DoDebitCurrent(int Accid, int amount)
    {
        cout << "Open DB\n";
        cout << "Debit Current\n";
        cout << "Close DB\n";
    }
};
```
**Template method pattern**
- Use of virtual function
```cpp
//Approved class
class Account
{
protected:
    virtual void ActualDebit(int Accid, int amount) = 0;

public:
    void Debit(int Accid, int amount)
    {
        cout << "Open DB\n";
        ActualDebit(Accid, amount);
        cout << "Close DB\n";
    }
};

class SavingsAccount :public Account
{
protected:
    void ActualDebit(int Accid, int amount) override
    {
        cout << "Debit Savings\n";
    }
};

class CurrentAccount :public Account
{
protected:
    void ActualDebit(int Accid, int amount) override
    {
        cout << "Debit Current\n";
    }
};

int main()
{
    SavingsAccount sa;
    sa.Debit(101, 100);
    line();
    CurrentAccount cu;
    cu.Debit(102, 200);
    return 0;
}
```

## std::function
std::function is a versatile and powerful tool in C++ that allows you to store and manipulate callable objects, such as functions, lambdas, function pointers, or functors, in a type-safe and flexible manner.

```cpp
#include <iostream>
#include <functional>

int add(int a, int b) {
    return a + b;
}

struct Multiply {
    int operator()(int a, int b) const {
        return a * b;
    }
};

void vendor(std::function<int(int,int)> fn)
{
    std::cout<<"Vendor start" << std::endl; 
    int result = fn(1,2);
    td::cout<<"Vendor Result: " << result << std::endl;
    std::cout<<"Vendor end" << std::endl;
}

int main() {
    
    std::function<int(int, int)> func;
    func = add;
    std::cout << "add(3, 4) = " << func(3, 4) << std::endl;

    Multiply multiply;
    func = multiply;
    std::cout << "multiply(3, 4) = " << func(3, 4) << std::endl;

    func = [](int a, int b) { return a - b; };
    std::cout << "subtract(3, 4) = " << func(3, 4) << std::endl;

    func = [](int a, int b) mutable -> int { return a - b; };
    std::cout << "subtract(3, 4) = " << func(3, 4) << std::endl;

    return 0;
}
```

## std::bind
std::bind is a function provided by the C++ Standard Library in the functional header. It allows you to create a callable object (function object) by binding arguments to a function or member function. 

```cpp
#include <iostream>
#include <functional>

void print_sum(int a, int b) {
    std::cout << "Sum: " << (a + b) << std::endl;
}

int main() {
    auto add_five = std::bind(print_sum, 5, std::placeholders::_1);
    add_five(10);

    auto add_nums = std::bind(print_sum, std::placeholders::_1, std::placeholders::_2);
    add_nums(7, 8);

    return 0;
}
```

```cpp
#include <iostream>
#include <functional>

void fn(int a, int b)
{
    std::cout << a << " " << b << std::endl;
}

int main()
{
    std::function<void()> f = std::bind(&fn, 1, 2);
    f();

    std::function<void(int)> f1 = std::bind(&fn, std::placeholders::_1, 2);
    f1(5);
    return 0;
}
```

```cpp
void Vendor3(std::function<int(int)> obj)
{
    cout << "start3\n";
    int res = obj(80);
    cout << "stop3 : res : " << res << '\n';
    line();
}

int main()
{    
    std::function<int(int)> fnc1 = std::bind(&ClientFun, i, placeholders::_1);
    Vendor3(fnc1);

    std::function<int(int)> fnc2 = std::bind(&ClientFun, placeholders::_1, i);
    Vendor3(fnc2);

    return 0;
}
```

### std::mem_fn
std::mem_fn is a utility function provided by the C++ Standard Library, defined in the functional header. It is used to create a callable object (function object) that can invoke a member function of a class or a pointer to member function.

```cpp
class Country
{
public:
    void Bharath(int x)
    {
        cout << "Bharath x : " << x << '\n';
    }
    void India(int x)
    {
        cout << "India x : " << x << '\n';
    }
    void Hindustan(int x)
    {
        cout << "Hindustan x : " << x << '\n';
    }
    void AlHindh(int x)
    {
        cout << "AlHindh x : " << x << '\n';
    }
};

int main()
{
    Country country;


    std::function<void(int)> fnc = std::bind(&Country::Bharath, country, placeholders::_1);
    fnc(100);

    std::function<void(Country&, int)> fnc1 = std::mem_fn(&Country::Bharath);
    fnc1(country, 10);
    return 0;
}
```

```cpp
void VendorFun(std::function<void(int)> fn)
{
    cout << "Start\n";
    fn(100);//callback
    cout << "Stop\n";
}

class Country
{
public:
    void Bharath(int x)
    {
        cout << "Bharath x : " << x << '\n';
    }
    void India(int x)
    {
        cout << "India x : " << x << '\n';
    }
    void Hindustan(int x)
    {
        cout << "Hindustan x : " << x << '\n';
    }
    void AlHindh(int x)
    {
        cout << "AlHindh x : " << x << '\n';
    }
};

int main()
{
    Country country;
    std::function<void(int)> fnc = std::bind(&Country::Hindustan, &country, placeholders::_1);
    VendorFun(fnc);
   
    std::function<void(Country&, int)>  fnc2 = mem_fn(&Country::AlHindh);

    std::function<void(int)> fnc3 = [&country, &fnc2](int par) { fnc2(country, par); };
    VendorFun(fnc3);
    line();
    return 0;
}
```

## Smart Pointer With Template
## Mutable Keyword To Override Const 
## Wrapper
## Functor

Sounds like: 
Func - function
tor - constructor 
Constructing out of functions - Function Object
We can think of using a object as a function. But objects have data and actions associated with them.
There fore functor is function with state
Key to use a object like a function OR to hold the stare of function : operator()

Lambda - constructs a closure
Closure - unnamed function object capable of capturing variables in scope 

## lvalue & rvalue

lvalue: something with a memory location. &(variable)
rvalue: on the right side of an assignment operator. Does not point anywhere

lvalue reference

possible: 
int x = 10;
int& ref = x;

not possible:

int& ref = 10; 
10 does't have a memory location so ref can not point to it

Rvalue reference
int&& ref = 10; 

Here 10 is created in a temp created where if in case of lvalue it will be copied and then stored to ref. but in case of r value referece it id directly moved hence avoiding copy

## Thread
Mutex
In multithreaded programming, a mutex (short for mutual exclusion) is a synchronization primitive used to control access to shared resources by multiple threads. Its main purpose is to prevent simultaneous access to shared data by multiple threads, which could lead to data corruption or race conditions.

